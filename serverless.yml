# The name of the service.
service: rust-lambda

# We want to host the project on AWS using Rust.
provider:
    name: aws
    runtime: rust

    iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:DescribeTable
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      Resource: "arn:aws:dynamodb:us-east-2:525480555872:table/OpenSchedule"

custom:
  rust:
    dockerTag: '0.2.7-rust-1.43.0'
# To automate building and deployment, we'll use a plugin specifically made for Rust.
plugins:
    - serverless-rust
    - serverless-dotenv-plugin

# This tells the framework to package each function separately with its own container.
package:
    individually: true

# Here is where we define all our functions (each living in a separate Cargo crate).
functions:
    # In this project, we only have one lambda function called `lucky_numbers`.
    create_open_schedule:
        # The name of the handler must match the name of the crate (not the actual function defined within).
        handler: create_schedule
        
        # This tells AWS when to trigger our function.
        events:
            # The event we're interested in is an incoming HTTP request.
            - http:
                  # The function will be called for every POST request that is made
                  # onto the `/lucky_numbers` endpoint.
                  path: /create_schedule
                  method: POST
    get_schedule:
      handler: get_schedule
      events:
        - http:
            path: /get_schedule
            method: GET
